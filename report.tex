\documentclass[a4paper, 10pt]{oblivoir}

\usepackage{fapapersize}
\usefapapersize{210mm, 297mm, 30mm, 30mm, 30mm, 30mm}

\usepackage[hangul]{kotex}
\usepackage{indentfirst}
\usepackage{makecell}
\usepackage{listings}
\usepackage{pdflscape}

\usepackage{tikz}
\usetikzlibrary{graphs, graphdrawing, automata,positioning}
\usegdlibrary{layered, force}
\lstset{language=C, basicstyle=\footnotesize}
\usepackage{forest}

\title{컴파일러 프로젝트 2 결과보고서}
\author{박건}
\date{2019년 5월 3일}

\begin{document}

\maketitle

\vspace*{\fill}

\begin{center}
\begin{tabular}{ l l }
과목명 & [CSE4120] 기초 컴파일러 구성 \\
담당교수 & 서강대학교 컴퓨터공학과 정성원 \\
개발자 & 박건 \\
개발기간 & 2019. 3. 24. - 2019. 5. 3. \\
\end{tabular}
\end{center}

\vspace*{\fill}

\pagebreak

\begin{tabular}{ l l }
프로젝트 제목: & \makecell{Design and Development of Compiler for C- Language: \\
Phase 2: Design and Implementation of LALR Parser} \\
제출일: & 2019. 5. 3.\\
개발자: & 박건 \\
\end{tabular}

\section{개발 목표}
C Language를 간소화한 언어인 C- Language에 대해 Syntax analysis를 수행할 수 있는 Parser를 구현한 후, AST(Abstract Syntax Tree)를 출력한다.

\section{개발 범위 및 내용}
\subsection{개발 범위}
Parser는 Syntax analysis를 하는 단계로, 전 단계의 Lexical analyzer가 소스 파일을 토큰으로 쪼갠 것을 이 언어의 Syntax에 맞는지 분석하는 단계이다. Type checking과 같은 Semantic analysis는 하지 않는다.

\subsection{개발 내용}
교재\footnote{Compiler Construction Principles and Practice, K. C. Louden}를 참고하여 \texttt{flex}와 \texttt{bison}을 연동하여 C- Language의 Parser를 구현하고, 성공적으로 파싱되었을 경우 AST(Abstract Syntax Tree)를 출력한다. 또한 Parsing error가 발생했을 때, 적절한 에러 메시지를 생성하도록 한다.

\section{추진 일정 및 개발 방법}
\subsection{추진 일정}
\begin{itemize}
\item 5월 2일: 개발, 결과 보고서 작성
\item 5월 3일: 과제 제출
\end{itemize}

\subsection{개발 방법}
Linux Desktop 환경에서 Qt Creator IDE를 이용하여 개발한다. 테스트는 cspro에서 돌려본다.

\section{연구 결과}
\subsection{합성 내용}
\tikz \graph [layered layout]
{
"\texttt{lex.l}" -> [densely dashed] {"\texttt{lex.yy.c}", "\texttt{lex.yy.h}"},
"\texttt{parser.y}" -> [densely dashed] {"\texttt{parser.tab.c}", "\texttt{parser.tab.h}"},
"\texttt{globals.h}" -> {"\texttt{util.h}", "\texttt{lex.l}", "\texttt{parser.y}", "\texttt{main.c}"},
"\texttt{lex.yy.h}" -> {"\texttt{parser.y}", "\texttt{util.c}",  "\texttt{main.c}"},
"\texttt{util.h}" -> {"\texttt{main.c}", "\texttt{util.c}"},
"\texttt{scan.h}" -> {"\texttt{scan.c}", "\texttt{globals.h}", "\texttt{lex.l}", "\texttt{main.c}", "\texttt{parser.y}", "\texttt{scan.c}", "\texttt{util.h}"},
"\texttt{parser.tab.h}" -> {"\texttt{globals.h}"},
};

\subsection{분석 내용}
\begin{itemize}
\item \texttt{lex.l} \newline
 \texttt{flex} Input file으로, Lexical analyzer를 만들어주는 소스이다.
\item \texttt{globals.h} \newline
 \texttt{yyerror()}의 프로토타입이 들어간다. 또한 \texttt{scan.h}와 \texttt{parser.tab.h}를 include한다.
\item \texttt{util.c} \newline
 AST(Abstract Syntax Tree)를 출력해주는 \texttt{printTree()} 함수 정의가 들어간다.
\item \texttt{main.c} \newline
 \texttt{main()} 함수와 \texttt{yyerror()}함수의 정의가 들어간다.
\item \texttt{scan.c}\newline
 AST를 생성해주는 루틴들이 정의되어 있다.
\end{itemize}

\subsection{제작 내용}
교재의 내용과 겹치는 부분은 따로 설명하지 않겠다.
이전 프로젝트와 같이 여러 파일을 한꺼번에 처리할 수 있도록 global 변수를 사용하지 않는 Reentrant 모드를 사용했다. Bison에서 Reentrant 모드를 사용하는 방법은 declaration 파트에 \texttt{\%define api.pure full} 라인을 넣어주면 된다.

\texttt{parser.y} 파일을 작성한 후에 \texttt{bison}을 실행해 보았더니, Shift/reduce conflict가 하나 있다는 메시지가 나왔다. Report 파일(\texttt{parser.output})을 확인해 보았더니, 다음과 같이 State 97에서 Shift/reduce conflict가 발생한다는 사실을 알 수 있었다.

\begin{lstlisting}[frame=single, caption=\texttt{parser.output}, breaklines=true]
State 97 conflicts: 1 shift/reduce
...
State 97
 
    29 selection_stmt: IF LPAREN expression RPAREN statement .  [IF, ELSE, RETURN, WHILE, SEMICOLON, LPAREN, LBRACE, RBRACE, ID, NUM]
    30               | IF LPAREN expression RPAREN statement . ELSE statement

     ELSE  shift, and go to state 100

     ELSE      [reduce using rule 29 (selection_stmt)]
     $default  reduce using rule 29 (selection_stmt) 
...
\end{lstlisting}

바로 \texttt{selection-stmt}문에서 \texttt{if} 블록이 끝났을 때 다음 토큰이 ELSE인 경우 Shift를 할지 Reduce를 할지 정할 수 없어 생기는 것이다. \texttt{bison}에서는 디폴트 동작으로 Reduce를 하였지만 그 다음 있는 else문까지 한 \texttt{if/else}문으로 파싱해 주는 것이 정당하다. 따라서 다음 라인을 추가해 Right-associative로 바꾸니 conflict가 해결되었다.

\begin{lstlisting}[frame=single]
%right RPAREN ELSE
\end{lstlisting}

\begin{lstlisting}[frame=single, caption=\texttt{parser.output} after \texttt{\%right} line added, breaklines=true]
...
State 97

   29 selection_stmt: IF LPAREN expression RPAREN statement .  [IF, RETURN, WHILE, SEMICOLON, LPAREN, LBRACE, RBRACE, ID, NUM]
   30               | IF LPAREN expression RPAREN statement . ELSE statement

    ELSE  shift, and go to state 100

    $default  reduce using rule 29 (selection_stmt)

    Conflict between rule 29 and token ELSE resolved as shift (%right ELSE).
...
\end{lstlisting}


그 밖에 덧셈과 곱셈 등의 우선순위를 정해 주는 것도 grammar부터 이미 ambiguity가 제거되어 있기 때문에 token의 순서와 precedence에 대해 신경 쓸 필요는 없었다.

만약 파싱 도중에 에러가 나면 현재 생성하고 있던 AST를 버리게 되는데, 이 과정에서 메모리 누수가 발생할 수 있다. 다행히 \texttt{bison}에서 destructor 기능을 제공하여 error가 나도 메모리를 정상적으로 해제할 수 있었다. 이 메커니즘은 다음과 같다.

\begin{lstlisting}[frame=single]
%destructor { freeNodeCascade($$); } <node>
%destructor { free($$); } <name>
\end{lstlisting}

만약 \texttt{node} 타입을 만들다가 에러가 나면 \texttt{freeNodeCascade()} 함수가 호출된다. 또한 \texttt{name} 타입을 만들다가 에러가 나면 \texttt{free()} 함수가 호출된다.

\texttt{printTree()} 함수는 재귀적으로 트리의 노드를 방문하면서 노드의 내용과 children을 출력한다. 노드의 종류는 다음과 같다.

\begin{itemize}
\item \texttt{ExprConst} \newline
숫자 literal을 담고 있는 expression이다. 출력될 때 다음과 같이 출력된다.
\begin{lstlisting}[frame=single]
Const : <number>
\end{lstlisting}

\item \texttt{ExprId} \newline
변수 expression이다. 다음과 같이 출력된다.
\begin{lstlisting}[frame=single]
Id : <name of variable>
\end{lstlisting}

\item \texttt{ExprIndex} \newline
\texttt{a[3]}과 같은 배열의 인덱스를 참조하는 expression이다. 다음과 같이 출력된다.
\begin{lstlisting}[frame=single]
Index id : <name of array>
  <index subexpression>
\end{lstlisting}

\item \texttt{ExprCall} \newline
\texttt{func(arg1, arg2)}와 같이 함수를 호출하는 expression이다. 다음과 같이 출력된다.
\begin{lstlisting}[frame=single]
Call id : <name of function>
  <argument expression 1> 
  <argument expression 2> 
  ...
\end{lstlisting}
 
\item \texttt{ExprBinOp} \newline
덧셈, 곱셈, 비교 연산과 같은 이항 연산 expression이다. 다음과 같이 출력된다.
\begin{lstlisting}[frame=single]
Op <op name>
  <left operand>
  <right operand>
\end{lstlisting}

\item \texttt{ExprAssign} \newline
대입 연산 expression이다. 다음과 같이 출력된다.
\begin{lstlisting}[frame=single]
Assign
  <left operand>
  <right operand>
\end{lstlisting}

\item \texttt{StmtReturn} \newline
Return statement이다. 다음과 같이 출력된다.
\begin{lstlisting}[frame=single]
Return
  <expression>
\end{lstlisting}

\item \texttt{StmtWhile} \newline
While statement이다. 다음과 같이 출력된다.
\begin{lstlisting}[frame=single]
While
  <condition>
  <body>
\end{lstlisting}

\item \texttt{StmtIf} \newline
If/else statement이다. 다음과 같이 출력된다.
\begin{lstlisting}[frame=single]
If
  <condition>
  <if-block>
  [<else-block>]
\end{lstlisting}
\texttt{<else-block>}은 없으면 출력되지 않는다.

\item \texttt{StmtExprStmt} \newline
Expression 자체로 statement가 되는 경우를 나타낸다. 다음과 같이 출력된다.
\begin{lstlisting}[frame=single]
<expression>
\end{lstlisting}

\item \texttt{StmtCompoundStmt} \newline
Function을 이루는 한 블록을 나타낸다. 다음과 같이 출력된다.
\begin{lstlisting}[frame=single]
Compound Statement
  <statement 1>
  <statement 2>
  ...
\end{lstlisting}

\item \texttt{StmtParamList} \newline
Parameter list를 나타낸다. 파라미터가 존재하면 다음과 같이 출력된다.
\begin{lstlisting}[frame=single]
Parameters
  <Param 1>
  <Param 2>
  ...
\end{lstlisting}

파라미터가 존재하지 않으면 다음과 같이 출력된다.
\begin{lstlisting}[frame=single]
Parameters
  (Void)
\end{lstlisting}

\item \texttt{StmtParam} \newline
Parameter 하나를 의미한다. 배열이 아닌 파라미터는 다음과 같이 출력된다.
\begin{lstlisting}[frame=single]
Parameter id : <parameter name>   Type : <parameter type>
\end{lstlisting}

배열이면 다음과 같이 출력된다.
\begin{lstlisting}[frame=single]
Parameter id : <parameter name>   Type : <parameter type>[]
\end{lstlisting}

\item \texttt{StmtFunction} \newline
함수 정의를 의미한다. 다음과 같이 출력된다.
\begin{lstlisting}[frame=single]
Function id : <function name>    Type : <return type>
  <parameter list>
  <function body>
\end{lstlisting}

\item \texttt{StmtVar} \newline
변수 선언을 의미한다. 배열이 아닌 변수 선언은 다음과 같이 출력된다.
\begin{lstlisting}[frame=single]
Variable id : <variable name>   Type : <variable type>
\end{lstlisting}

배열이면 다음과 같이 출력된다.
\begin{lstlisting}[frame=single]
Variable id : <variable name>   Type : <variable type>[]
\end{lstlisting}

\item \texttt{StmtDeclList} \newline
전체 프로그램은 declaration list를 이룬다. 따라서 다음과 같이 출력된다.
\begin{lstlisting}[frame=single]
Syntax Tree:
  <declaration 1>
  <declaration 2>
  ...
\end{lstlisting}

\end{itemize}

파싱 도중 에러가 생겼을 경우 \texttt{yyerror()}가 호출되는데, 여기서 상세한 에러 메시지를 출력하기 위해서 \texttt{bison}에 옵션 \texttt{\%define parse.error verbose}를 넘겨주었다.

\subsection{시험 내용}
프로그램 실행 방법은 다음과 같다.
\begin{lstlisting}[frame=single]
$ make
$ ./20171634 errorfree.c
\end{lstlisting}

교재에 있는 C- Language 예제 코드 2가지를 입력해 시험하고, 또한 예제 파일 \texttt{errorfree.c}와 \texttt{error.c}를 만들어 시험했다. \texttt{error.c}는 Syntax 에러를 일으키는 코드로, line number를 포함한 에러 메시지가 제대로 나오는지 확인했다. 

\section{기타}
\subsection{자체 평가}
\texttt{bison}과 \texttt{flex}의 Reentrant mode를 사용하여 구조적으로 프로그램을 작성했고, 여러 파일을 한꺼번에 입력할 수 있다는 점에서 다른 사람과 구별된다고 생각한다. 또한 \texttt{bison}의 destructor 기능을 이용해 에러 상황에도 메모리를 적절히 해제해 메모리 누수를 방지했다. 그 결과 유지 보수가 용이하고 확장성 있는 코드를 작성할 수 있었다.

또한 추가 기능으로서 \texttt{--latex} 을 프로그램 인자로 주면 \LaTeX 형식으로 트리를 만들 수 있다. 다음은 이 기능으로 그린 트리이다.
\begin{lstlisting}[frame=single]
$ ./20171634 --latex test1.c
\end{lstlisting}

\begin{landscape}
\begin{forest}
[{Program}
  [{Var x : int[20]}]
  [{Fun gcd : int}
    [{Parameters}
      [{u : int[]}]
      [{v : int}]
    ]
    [{Compound Statement}
      [{If}
        [{==}
          [{v}]
          [{0}]
        ]
        [{Return}
          [{u}]
        ]
      ]
      [{If}
        [{==}
          [{v}]
          [{1}]
        ]
        [{Return}
          [{u}]
        ]
        [{Return}
          [{Call gcd}
            [{v}]
            [{-}
              [{u}]
              [{*}
                [{/}
                  [{u}]
                  [{v}]
                ]
                [{v}]
              ]
            ]
          ]
        ]
      ]
    ]
  ]
  [{Fun main : void}
    [{Parameters}
      [{(Void)}]
    ]
    [{Compound Statement}
      [{Var x : int}]
      [{Var y : int}]
      [{Assign}
        [{Index x}
          [{1}]
        ]
        [{2}]
      ]
      [{Assign}
        [{x}]
        [{Call input}
        ]
      ]
      [{Assign}
        [{y}]
        [{Call input}
        ]
      ]
      [{Call output}
        [{Call gcd}
          [{x}]
          [{y}]
        ]
      ]
    ]
  ]
]
\end{forest}
\end{landscape}

\end{document}