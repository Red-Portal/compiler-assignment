\documentclass[a4paper, 10pt]{oblivoir}

\usepackage{fapapersize}
\usefapapersize{210mm, 297mm, 30mm, 30mm, 30mm, 30mm}

\usepackage[hangul]{kotex}
\usepackage{indentfirst}
\usepackage{makecell}
\usepackage{listings}

\usepackage{tikz}
\usetikzlibrary{graphs, graphdrawing, automata,positioning}
\usegdlibrary{layered, force}
\lstset{language=C, basicstyle=\footnotesize}

\title{컴파일러 프로젝트 1 결과보고서}
\author{박건}
\date{2019년 3월 24일}

\begin{document}

\maketitle

\vspace*{\fill}

\begin{center}
\begin{tabular}{ l l }
과목명 & [CSE4120] 기초 컴파일러 구성 \\
담당교수 & 서강대학교 컴퓨터공학과 정성원 \\
개발자 & 박건 \\
개발기간 & 2019.3.24 - 2019.3.24 \\
\end{tabular}
\end{center}

\vspace*{\fill}

\pagebreak

\begin{tabular}{ l l }
프로젝트 제목: & \makecell{Design and Development of Compiler for C- Language: \\
Phase 1: Design and Implementation of Lexical Analyzer} \\
제출일: & 2019. 3. 24.\\
개발자: & 박건 \\
\end{tabular}

\section{개발 목표}
C- Language의 Lexical Analyzer를 구현한다. C- Language는 C Language를 간소화한 언어이다.

\section{개발 범위 및 내용}
\subsection{개발 범위}
Lexical Analyzer는 Input Character들을 Token으로 쪼개는 역할을 하며, 동시에 Comment를 제거하는 기능을 한다.

\subsection{개발 내용}
\texttt{flex}를 이용하여 C- Language의 Lexical Analyzer를 구현한다.

\section{추진 일정 및 개발 방법}
\subsection{추진 일정}
3월 24일: 개발, 결과 보고서 작성
3월 27일: 과제 제출

\subsection{개발 방법}
Linux Desktop 환경에서 Qt Creator IDE를 이용하여 개발한다.

\section{연구 결과}
\tikz \graph [layered layout]
{
"\texttt{tiny.l}" -> [densely dashed] {"\texttt{lex.yy.c}", "\texttt{lex.yy.h}"},
"\texttt{globals.h}" -> {"\texttt{main.c}", "\texttt{utils.c}", "\texttt{tiny.l}"},
"\texttt{lex.yy.h}" -> {"\texttt{main.c}"}
};

\tikz \graph [layered layout]
{
"\texttt{main()}" -> {"\texttt{assemble()}", "\texttt{type()}", "\texttt{symbol()}"},
"\texttt{assemble()}" -> {"\texttt{first\_pass()}", "\texttt{symtab\_init()}"},
"\texttt{assemble()}" -> [minimum layers=3] {"\texttt{second\_pass()}"},
"\texttt{first\_pass()}" -> {"\texttt{parse\_line()}", "\texttt{calc\_ins\_length()}", "\texttt{symtab\_find()}", "\texttt{symtab\_insert()}"},
"\texttt{second\_pass()}" -> {"\texttt{switch\_extension()}", "\texttt{parse\_im\_line()}", "\texttt{assemble\_ins()}"},
"\texttt{parse\_im\_line()}" -> {"\texttt{parse\_line()}"},
"\texttt{symbol()}" -> {"\texttt{print\_symtab\_list\_sorted()}"},

};

\begin{itemize}
\item \texttt{tiny.l} -- \texttt{flex} Input file. 토큰들의 Regular expression 정의와 Comment parsing 알고리즘이 들어간다.
\item \texttt{globals.h} -- \texttt{enum Token}의 정의와 Enumeration 값을 문자열로 바꿔 주는 \texttt{enum\_to\_string()} 함수 선언, \texttt{struct Scanner}의 정의가 들어간다.
\item \texttt{utils.c} -- \texttt{enum\_to\_string()} 함수 정의가 들어간다.
\item \texttt{main.c} -- \texttt{main()} 함수가 들어간다.
\item \texttt{lex.yy.c} -- \texttt{tiny.l}에서 flex가 생성해준 파일로, 문자열을 파싱해주는 \texttt{yylex()} 함수가 정의되어 있다.
\item \texttt{lex.yy.h} -- \texttt{tiny.l}에서 flex가 생성해준 헤더 파일로, \texttt{lex.yy.c}에 정의되어 있는 여러 함수들이 선언되어 있다.
\end{itemize}

Lexical analyzer를 테스트하기 위해 \texttt{test\_files/} 디렉로리 안에 \texttt{test1.tny}와 \texttt{test2.tny} 예제 소스 코드를 만들었다. \texttt{test1.tny}는 정상적으로 Tokenize 되어야 하는 Binary search의 소스 코드를 담고 있으며, \texttt{test2.tny}는 잘못 작성된 Comment가 포함되어 있어 오류가 나야 하는 파일이다.

\lstinputlisting[caption=test\_files/test1.tny, frame=single]{test_files/test1.tny}
\lstinputlisting[caption=test\_files/test2.tny, frame=single]{test_files/test2.tny}

이 두 파일을 이용하여 아래 Command를 이용하여 테스트한 결과는 다음과 같다.
\begin{lstlisting}
$ ./compiler test_files/test1.tny test_files/test2.tny
\end{lstlisting}

\begin{lstlisting}[caption=Output, frame=single]
test_files/test1.tny:
 line number    token         lexeme    
-----------------------------------------
   1            INT         int
   1            ID          arr
   1            LBRACKET    [
   1            NUM         100
   1            RBRACKET    ]
   1            SEMICOLON   ;
   4            INT         int
   4            ID          binarysearch
   4            LPAREN      (
   4            INT         int
   4            ID          x
   4            RPAREN      )
   5            LBRACE      {
   6            INT         int
   6            ID          left
   6            ASSIGN      =
   6            NUM         0
   6            COMMA       ,
   6            ID          right
   6            ASSIGN      =
   6            NUM         100
   6            SEMICOLON   ;
   7            INT         int
   7            ID          mid
   7            SEMICOLON   ;
   9            WHILE       while
   9            LPAREN      (
   9            ID          left
   9            LESSTHANEQ  <=
   9            ID          right
   9            RPAREN      )
  10            LBRACE      {
  11            ID          mid
  11            ASSIGN      =
  11            LPAREN      (
  11            ID          left
  11            PLUS        +
  11            ID          right
  11            RPAREN      )
  11            DIVIDE      /
  11            NUM         2
  11            SEMICOLON   ;
  12            IF          if
  12            LPAREN      (
  12            ID          mid
  12            EQUAL       ==
  12            ID          x
  12            RPAREN      )
  12            RETURN      return
  12            ID          mid
  12            SEMICOLON   ;
  13            ELSE        else
  13            IF          if
  13            LPAREN      (
  13            ID          mid
  13            LESSTHAN    <
  13            ID          x
  13            RPAREN      )
  13            ID          left
  13            ASSIGN      =
  13            ID          mid
  13            PLUS        +
  13            NUM         1
  13            SEMICOLON   ;
  14            ELSE        else
  14            ID          right
  14            ASSIGN      =
  14            ID          mid
  14            MINUS       -
  14            NUM         1
  14            SEMICOLON   ;
  15            RBRACE      }
  16            RETURN      return
  16            MINUS       -
  16            NUM         1
  16            SEMICOLON   ;
  17            RBRACE      }
  19            INT         int
  19            ID          main
  19            LPAREN      (
  19            VOID        void
  19            RPAREN      )
  20            LBRACE      {
  21            INT         int
  21            ID          i
  21            COMMA       ,
  21            ID          goal
  21            COMMA       ,
  21            ID          res
  21            SEMICOLON   ;
  22            ID          for
  22            LPAREN      (
  22            ID          i
  22            ASSIGN      =
  22            NUM         0
  22            SEMICOLON   ;
  22            ID          i
  22            LESSTHAN    <
  22            NUM         100
  22            SEMICOLON   ;
  22            ID          i
  22            PLUS        +
  22            PLUS        +
  22            RPAREN      )
  23            LBRACE      {
  24            ID          arr
  24            LBRACKET    [
  24            ID          i
  24            RBRACKET    ]
  24            ASSIGN      =
  24            ID          i
  24            SEMICOLON   ;
  25            RBRACE      }
  26            ID          goal
  26            ASSIGN      =
  26            NUM         100
  26            SEMICOLON   ;
  27            ID          res
  27            ASSIGN      =
  27            ID          binarysearch
  27            LPAREN      (
  27            ID          goal
  27            RPAREN      )
  27            SEMICOLON   ;
  28            RETURN      return
  28            NUM         0
  28            SEMICOLON   ;
  29            RBRACE      }
  30            ENDOFFILE   
test_files/test2.tny:
 line number    token         lexeme    
-----------------------------------------
  11            ERROR       Comment error
  11            ENDOFFILE
\end{lstlisting}

예상했던 대로 \texttt{test1.tny}는 정상적으로 Tokenize 되고, \texttt{test2.tny}는 ``Comment error''가 나오는 것을 확인할 수 있다.

위의 Command에서도 볼 수 있듯이 여러 파일을 한꺼번에 처리하기 위해서 flex의 옵션 중 하나인 Reentrant mode (\texttt{\%option reentrant})를 사용하였다. 이 옵션은 \texttt{yylex()}가 Global state를 접근하지 않게 파싱 상태를 모듈화할 수 있게 해 준다. 이 옵션을 이용하기 위해서 아래와 같이 \texttt{globals.h}에 \texttt{Scanner} 구조체를 선언하였다. \texttt{void* flex}는 \texttt{yylex()}가 사용하는 내부 state를 가리키는 포인터, \texttt{const char* error\_msg}는 현재 에러 메시지를 가리키는 포인터이다.

\begin{lstlisting}
struct Scanner {
    void* flex;
    const char* error_msg;
};
\end{lstlisting}

Reentrant mode를 사용하면 \texttt{flex}를 사용하는 방식이 조금 바뀐다. 먼저, \texttt{yylex()}를 호출하기 전에 \texttt{yylex\_init()}함수에 \texttt{scanner}객체의 \texttt{flex}포인터를 전달해야 한다. 그 다음 Input stream을 지정해 주기 위해 \texttt{yyset\_in()}함수를 호출하고, 에러 메시지 저장을 위해 \texttt{yyset\_extra()} 함수를 통해 scanner 오브젝트의 포인터를 전달해 준다. 이 포인터는 \texttt{tiny.l} 파일에서 \texttt{yyget\_extra()} 함수를 통해 접근할 수 있다. 그 다음 \texttt{yylex()} 함수를 호출할 때는 \texttt{flex} 포인터 값을 인자로 전달해 주어야 한다. 그리고 모든 과정이 끝나면 \texttt{yylex\_destroy()} 함수를 호출해 내부 State를 할당 해제해 주어야 한다. 이것을 적용한 후의 코드는 다음과 같다.

\begin{lstlisting}[caption=Segment of main.c, frame=single]
    for (int i = 1; i < argc; ++i) {

        FILE* fp;
        if ((fp = fopen(argv[i], "r")) == NULL) {
            fprintf(stderr, "Error: Cannot open file \"%s\"\n", argv[i]);
            return 1;
        }

        if (argc > 2) {
            // print file name
            printf("%s:\n", argv[i]);
        }

        struct Scanner scanner;

        // set input stream
        yylex_init(&scanner.flex);
        yyset_in(fp, scanner.flex);
        yyset_extra(&scanner, scanner.flex);

        puts(" line number    token         lexeme    ");
        puts("-----------------------------------------");

        enum Token result;
        do {
            result = yylex(scanner.flex);
            printf("%4d            ", yyget_lineno(scanner.flex));
            printf("%-10s  ", enum_to_string(result));
            if (result == ERROR) {
                printf("%s\n", scanner.error_msg);
            }
            else {
                printf("%s\n", yyget_text(scanner.flex));
            }
        } while (result != ENDOFFILE);

        yylex_destroy(scanner.flex);

        fclose(fp);
    }
\end{lstlisting}

위와 같이 여러 파일을 처리할 때 Global state를 초기화하는 대신 \texttt{yylex\_init()}을 이용하여 state를 할당 및 초기화 하고 \texttt{struct Scanner}로 모듈화되어 멀티스레딩이나 프로젝트 크기가 커져도 유지관리를 쉽게 할 수 있다.

Comment 파싱은 아래와 같은 NFA를 구상한 다음 C코드로 구현하였다.

\begin{figure}
\begin{tikzpicture}[shorten >=1pt,node distance=3cm,on grid,auto] 
   \node[state,initial] (s3) {}; 
   \node[state] (s2)[right=of s3] {}; 
   \node[state] (s1)[right=of s2] {}; 
   \node[state] (s)[right=of s1] {}; 
   \node[state, accepting] (q_1) [right=of s] {}; 
   \node[state] (q_2) [below=of s] {error}; 
   
   \path[->] 
   	 (s) edge node {/} (q_1)
   	 (s) edge [loop, swap] node {*} (s)
   	 (s3) edge node {/} (s2)
   	 (s2) edge node {*} (s1)
   	 (s1) edge [bend left] node {*} (s)
   	 (s) edge [bend left] node {\Sigma} (s1)
   	 (s1) edge [loop, swap] node {\Sigma} (s1)
   	 (s1) edge node [swap] {<<EOF>>} (q_2)
   	 (s) edge node {<<EOF>>} (q_2);
\end{tikzpicture}
\caption{Comment parser}
\end{figure}

\begin{lstlisting}[caption=Segment of tiny.l, frame=single]
"/*"        {
    int c;
    while (1) {
        c = input(yyscanner);
        if (c == 0) {
            yyextra->error_msg = "Comment error";
            return ERROR;
        }
        if (c == '\n') {
            yylineno++;
        }
        while (c == '*') {
            c = input(yyscanner);
            if (c == 0) {
                yyextra->error_msg = "Comment error";
                return ERROR;
            }
            if (c == '\n') {
                yylineno++;
            }
            if (c == '/') {
                goto ignore;
            }
        }
    }
ignore:
    ;
}
\end{lstlisting}

\section{기타}
\subsection{자체 평가}
\texttt{flex}의 Reentrant mode를 사용하여 구조적으로 프로그램을 작성했고, 여러 파일을 한꺼번에 입력할 수 있다는 점에서 다른 사람과 구별된다고 생각한다. 또한 Comment parsing을 위해 NFA를 구상했다는 점에서 창의적으로 문제를 해결했다고 할 만하다.

\end{document}